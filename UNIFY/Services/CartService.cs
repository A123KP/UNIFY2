using Microsoft.EntityFrameworkCore;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using UNIFY.Data;
using UNIFY.Models; // For UNIFY.Models.Cart

namespace UNIFY.Services
{
    public class CartService : ICartService
    {
        private readonly AppDbContext _context;

        public CartService(AppDbContext context)
        {
            _context = context;
        }

        // Method now accepts a list of the EF Core Cart model
        // It assumes UserId has been set on each item by the controller
        public async Task SaveCartAsync(List<Cart> cartItemsFromController)
        {
            if (cartItemsFromController == null || !cartItemsFromController.Any())
            {
                // Or handle as an error, though the controller might check this too
                await _context.SaveChangesAsync(); // Ensure any pending changes are saved if logic before this point made any
                return;
            }

            // All items in cartItemsFromController should belong to the same user.
            // The UserId should have been set by the CartController.
            int userId = cartItemsFromController.First().UserId;
            if (userId == 0)
            {
                // This indicates an issue, UserId should be set by the controller
                throw new System.ArgumentException("UserId is not set on the cart items.", nameof(cartItemsFromController));
            }

            var existingCartItemsInDb = await _context.Carts
                                                  .Where(c => c.UserId == userId)
                                                  .ToListAsync();

            // Items to remove from DB:
            // Those in DB but not in the incoming cartItemsFromController (with quantity > 0)
            // Or those in cartItemsFromController but with quantity <= 0
            var itemsToRemove = existingCartItemsInDb
                .Where(dbItem => !cartItemsFromController.Any(cItem => cItem.ProductId == dbItem.ProductId && cItem.Quantity > 0) ||
                                 cartItemsFromController.Any(cItem => cItem.ProductId == dbItem.ProductId && cItem.Quantity <= 0))
                .ToList();

            if (itemsToRemove.Any())
            {
                _context.Carts.RemoveRange(itemsToRemove);
            }

            foreach (var controllerItem in cartItemsFromController.Where(ci => ci.Quantity > 0))
            {
                var existingItemInDb = existingCartItemsInDb
                                    .FirstOrDefault(c => c.ProductId == controllerItem.ProductId);

                if (existingItemInDb != null)
                {
                    // Update quantity if it has changed
                    if (existingItemInDb.Quantity != controllerItem.Quantity)
                    {
                        existingItemInDb.Quantity = controllerItem.Quantity;
                        _context.Carts.Update(existingItemInDb);
                    }
                }
                else
                {
                    // Add new item to cart.
                    // The controllerItem already has UserId, ProductId, and Quantity set.
                    // CartId will be generated by the database.
                    // Navigation properties (User, Product) will be null and EF will handle relationships via foreign keys.
                    var newCartEntry = new Cart
                    {
                        UserId = controllerItem.UserId, // Already set by controller
                        ProductId = controllerItem.ProductId,
                        Quantity = controllerItem.Quantity
                        // CartId is auto-generated
                        // User and Product navigation properties are not needed here for adding
                    };
                    await _context.Carts.AddAsync(newCartEntry);
                }
            }

            await _context.SaveChangesAsync();
        }
    }
}
